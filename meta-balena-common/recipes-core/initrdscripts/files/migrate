#!/bin/bash

# Copyright 2022 Balena Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# OS migration
#
# Expects to find flash-boot and a mounted flash-rootA rootfs in the boot disk

# shellcheck disable=SC1091
. /usr/libexec/os-helpers-logging
# shellcheck disable=SC1091
. /usr/libexec/os-helpers-fs
# shellcheck disable=SC1091
. /usr/sbin/balena-config-defaults

# ensure logs are written and filesystems are unmounted before exiting
cleanup() {
    sync
    umount -a
}

trap cleanup EXIT

# Enable module function
migrate_enabled() {
    # shellcheck disable=SC2154
    if [ "$bootparam_flasher" = "true" ]; then
        # flash-rootA has been identified as rootfs

        _flash_file_name=$(basename "${FLASHER_FILEFLAG}")
        if [ -f "${ROOTFS_DIR}/flash-boot/${_flash_file_name}" ]; then
            # shellcheck disable=SC1090
            . "${ROOTFS_DIR}/etc/resin-init-flasher.conf"

            # Migration use cases are:
            #
            # * Booting with only one disk - migrate if this disk is the one
            #   configured to program into
            # * Booting with multiple disks - only migrate if explicitely
            #   configured to do so as the user might want to install on
            #   alternative disks
            #
            internal_dev=$(get_internal_device "${INTERNAL_DEVICE_KERNEL}")
            boot_dev=$(findmnt --noheadings --canonicalize --output SOURCE "${ROOTFS_DIR}" | xargs lsblk -no pkname)
            FLASH_BOOT_DEVICE=$(get_dev_path_in_device_with_label "/dev/${boot_dev}" "flash-boot")
            if [ -n "${FLASH_BOOT_DEVICE}" ]; then
                FLASH_BOOT_MOUNT="/mnt/flash-boot"
                mkdir -p "${FLASH_BOOT_MOUNT}"
                mount "${FLASH_BOOT_DEVICE}" "${FLASH_BOOT_MOUNT}"
                if [ "$bootparam_migrate" = "true" ] || jq -re '.installer.migrate.force' "${FLASH_BOOT_MOUNT}/config.json" > /dev/null; then
                    _migrate=1
                    info "Migration requested in configuration"
                fi
            else
                fail "Flash boot partition not found in ${internal_dev}"
            fi

            # Migrate if configured to do so or if there is only one disk
            # (excluding RAM and swap devices)
            if [[ ( -n "${_migrate}" && "${_migrate}" = "1" ) || $(lsblk -nde 251,1 | wc -l) -eq "1" ]]; then
                info "Running migration on ${internal_dev}..."
                return 0
            fi
        fi

        if is_secured && [ "${_migrate}" != "1" ]; then
            fail "Locked devices can only be installed from memory"
        fi

        # Leave flashing after pivot-rooting
        if mountpoint "${FLASH_BOOT_MOUNT}"; then
            umount "${FLASH_BOOT_MOUNT}" > /dev/null || true
        fi
    fi
    # standard boot
    return 1
}

# When copying to zram, we're unable to use traditional methods of limiting
# memory usage such as ulimits and control groups. Memory used by zram is used
# by the kernel. We can't just let the copy process cause an OOM, as we'd be
# unable to effectively write anything to the logs for debugging afterwards.
#
# We also can't reliably predict how much memory we need to copy a given file
# to zram, as the compression ratio varies at runtime depending on the file's
# content.
#
# Instead, let's run the copy operation as a background job and keep an eye on
# available memory. If it drops below the reserve we set, we'll kill the
# operation and write a message to the log before bailing out.
cp_memsafe() {
    cp "${@}" &
    pid=$!
    available_reserve=$(( 64 * 1024 )) # 64 MB

    while kill -0 $pid 2>/dev/null; do
        mem_available=$(awk '/MemAvailable/{ print $2 }' /proc/meminfo)
        if [ "${mem_available}" -lt "${available_reserve}" ]; then
            kill $pid 2>/dev/null
            fail "Unable to copy files, not enough memory"
        fi
    done

    wait $pid
}

# Main module function
migrate_run() {
    # Find the raw image in the rootfs partition
    image=$(find "${ROOTFS_DIR}" -xdev -type f -name "${BALENA_IMAGE}")
    kernel_images=$(find "${ROOTFS_DIR}" -xdev -type f -name "@@KERNEL_IMAGETYPE@@*")
    if [ -n "${image}" ]; then
        EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT="${BALENA_BOOT_MOUNTPOINT}"
        if findmnt "${FLASH_BOOT_MOUNT}" > /dev/null; then
            _image_size=$(du -cb "${image}" | awk '/total/{print $1}')
            _flash_boot_size=$(du -cb ${FLASH_BOOT_MOUNT} | awk '/total/{print $1}')
            # shellcheck disable=SC2086
            _kernel_images_size=$(du -cb ${kernel_images} | awk '/total/{print $1}')
            total_size=$(("$_image_size" + "$_flash_boot_size" + "$_kernel_images_size"))
        else
            fail "Flash boot partition not found in ${internal_dev}"
        fi

        # Setup zram to contain large, compressible installation images to
        # reduce memory requirements
        #
        # round the zram dev size up to the nearest multiple of $zram_dev_size_mul_b
        zram_dev_size_mul_b=$((128 * 1024 * 1024))
        zram_dev_size_b=$(( ( total_size / zram_dev_size_mul_b + 1 ) * zram_dev_size_mul_b ))
        zram_alg=zstd

        # zramctl will occasionally fail the first time with EBUSY
        for _ in $(seq 1 5); do
            zram_dev=$(zramctl --find \
                               --algorithm "${zram_alg}" \
                               --size "${zram_dev_size_b}") \
                        && break
            sleep 0.1
        done

        if [ -n "${zram_dev}" ]; then
            zram_dev_alg=$(awk -F '[][]' '{print $2}' "/sys/class/block/$(basename "${zram_dev}")/comp_algorithm")
            zram_dev_size_gb=$(echo ${zram_dev_size_b} | awk '{print $1/1024/1024/1024}')

            info "Created ${zram_dev_size_gb} GB zram device using ${zram_dev_alg} alg"

            mke2fs -O ^has_journal "${zram_dev}"
            mkdir -p /mnt/zram "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}"
            mount "${zram_dev}" /mnt/zram

            mount -o bind /mnt/zram /tmp
            mount -o bind /mnt/zram "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}"
        else
            fail "Unable to create zram device"
        fi

        # Copy the raw image to zram
        cp_memsafe "${image}" "/tmp"

        # Copy the flasher boot partition into memory (contains configuration)
        cp_memsafe -r "${FLASH_BOOT_MOUNT}"/* "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}/"

        # Copy the flasher kernel images to memory
        # shellcheck disable=SC2086
        cp_memsafe -a ${kernel_images} "/tmp"

        # Need to source this again to set CONFIG_PATH correctly
        unset CONFIG_PATH
        # shellcheck disable=SC1091
        . /usr/sbin/balena-config-defaults

        mkdir -p "$(dirname "${CONFIG_PATH}")"
        _config_json_name=$(basename "${CONFIG_PATH}")
        cp "${FLASH_BOOT_MOUNT}/${_config_json_name}" "${CONFIG_PATH}"

        umount "${FLASH_BOOT_MOUNT}" > /dev/null || true
        sync "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}"
        # Unmount the rootfs as we are going to program over
        umount "${ROOTFS_DIR}"

        # If booting from the same disk we want to program, reboot after flashing
        if [ "${internal_dev#/dev/}" = "${boot_dev}" ]; then
            if [ -f "/etc/resin-init-flasher.conf" ]; then
                echo "POSTINSTALL_REBOOT=1" >> "/etc/resin-init-flasher.conf"
            else
                fail "Flasher configuration not found"
            fi
        fi

        # Run flasher - should not return
        /usr/bin/resin-init-flasher || fail "Flasher exited with $?"
    else
        # If recovery mode, wait for adbd to exit
        if [ -n "${ADBD_PID}" ]; then
            # adbd is not a child process so cannot wait
            while kill -0  "${ADBD_PID}" 2>/dev/null; do sleep 1; done
        fi
        fail "No ${BALENA_IMAGE} found in ${ROOTFS_DIR}"
    fi
}
