#!/bin/sh

set -e

export DOCKER_HOST="unix:///var/run/balena-engine.sock"

# shellcheck disable=SC1091
. /usr/libexec/os-helpers-logging

BALENA_HOSTAPP_EXTENSIONS_LABEL="io.balena.image.class"
BALENA_HOSTAPP_EXTENSIONS_VALUE="overlay"
BALENA_HOSTAPP_EXTENSIONS_DEFAULT="/etc/hostapp-extensions.conf"
DOCKER_OVERLAY_ROOT="/var/lib/docker/overlay2/"

# Track registries we've authenticated to (avoid duplicate logins)
authenticated_registries=""

script_name="$(basename "$0")"
readonly script_name
usage() {
	cat <<EOF
Usage: ${script_name} [OPTIONS]
	-t Space separated list of repository tags for hostapp extension containers
	-l Additional labels to apply (comma-separated key=value pairs)
	-r Reboot after update
EOF
	exit 0
}

extra_labels=""

while getopts 'hrt:l:' flag; do
	case "${flag}" in
	r) reboot=1 ;;
	t) target_hostext_images="${OPTARG}" ;;
	l) extra_labels="${OPTARG}" ;;
	h) usage ;;
	*) error "Unexpected option ${flag}" ;;
	esac
done

shift $#

# Don't source before parsing args as balena-config-vars parses args too
# shellcheck disable=SC1091
. /usr/sbin/balena-config-vars

# shellcheck disable=SC2317 # Called via trap
error_handler() {
	# shellcheck disable=SC2181
	[ $? -eq 0 ] && exit 0
	exit 1
}

trap error_handler EXIT

current_hostext_images=""
install_failed=0

update_current_host_extensions() {
	if [ -z "${current_hostext_images}" ]; then
		current_hostext_images="${hostext}"
	else
		current_hostext_images="${current_hostext_images} ${hostext}"
	fi
}

umount_merged() {
	mergeddir=$(${DOCKER} inspect -f '{{.GraphDriver.Data.MergedDir}}' "${1}" 2> /dev/null) || mergeddir=""
	if [ -n "${mergeddir}" ]; then
		mergeddir=${mergeddir#"${DOCKER_OVERLAY_ROOT}"}
		overlay=$(findmnt --noheadings --canonicalize  -t overlay -l -o TARGET | grep "${mergeddir}" || true)
		if [ -n "${overlay}" ]; then
			umount -l "${overlay}" || true
		fi
	fi
}

# Check if a container is dead (failed removal)
# Returns 0 if dead, 1 otherwise
is_container_dead() {
	cid="$1"
	dead=$(${DOCKER} inspect --format '{{.State.Dead}}' "${cid}" 2>/dev/null) || dead="false"
	[ "${dead}" = "true" ]
}

# Check if a container's overlay is part of the root overlay stack
# Returns 0 if mounted as lowerdir of /, 1 otherwise
is_mounted_in_root_overlay() {
	cid="$1"
	mergeddir=$(${DOCKER} inspect -f '{{.GraphDriver.Data.MergedDir}}' "${cid}" 2>/dev/null) || return 1
	[ -z "${mergeddir}" ] && return 1
	mergeddir=${mergeddir#"${DOCKER_OVERLAY_ROOT}"}

	# Check if this path appears in the root overlay mount options
	root_mount=$(findmnt -n -o OPTIONS / 2>/dev/null) || return 1
	case "${root_mount}" in
		*"${mergeddir}"*) return 0 ;;
		*) return 1 ;;
	esac
}

# Extract registry from image name
# e.g., "registry2.balena-cloud.com/v2/abc123" -> "registry2.balena-cloud.com"
# e.g., "myregistry.io/org/image:tag" -> "myregistry.io"
# Returns empty for Docker Hub images (no registry prefix)
get_registry() {
	image="$1"
	# Check if image has a registry (contains a dot before the first slash)
	case "${image}" in
		*.*/*)
			# Has registry - extract it (everything before the first slash)
			echo "${image%%/*}"
			;;
		*)
			# No registry prefix (Docker Hub or local)
			echo ""
			;;
	esac
}

# Check if a registry is configured as insecure in daemon.json
# Returns 0 (true) if insecure, 1 (false) otherwise
is_insecure_registry() {
	registry="$1"
	[ -z "${registry}" ] && return 1
	if [ -f /etc/docker/daemon.json ]; then
		grep -q "\"${registry}\"" /etc/docker/daemon.json 2>/dev/null && return 0
	fi
	return 1
}

# Login to registry using device credentials
# Uses UUID and DEVICE_API_KEY from balena-config-vars
registry_login() {
	registry="$1"
	[ -z "${registry}" ] && return 0

	# Check if already authenticated to this registry
	case " ${authenticated_registries} " in
		*" ${registry} "*)
			return 0
			;;
	esac

	# Need device credentials for authentication
	if [ -z "${UUID}" ] || [ -z "${DEVICE_API_KEY}" ]; then
		warn "Device credentials not available, skipping registry login"
		return 1
	fi

	# Login using device credentials
	if echo "${DEVICE_API_KEY}" | ${DOCKER} login "${registry}" -u "${UUID}" --password-stdin > /dev/null 2>&1; then
		authenticated_registries="${authenticated_registries} ${registry}"
		info "Authenticated to ${registry}"
		return 0
	else
		warn "Failed to authenticate to ${registry}"
		return 1
	fi
}

# The target hostapp extensions is a space separated list of docker repository
# tags in the form repo/name:tag, e.g balena/default:v1 balena/extra:v2
#
# Select target hostapp extensions in order of preference:
# Command line argument
# hostappExtensions entry in config.json
# Image default from /etc/hostapp-extensions.conf
if [ -z "${target_hostext_images}" ]; then
	if [ -z "${HOSTEXT_IMAGES}" ]; then
		target_hostext_images=$(cat ${BALENA_HOSTAPP_EXTENSIONS_DEFAULT})
	else
		target_hostext_images="${HOSTEXT_IMAGES}"
	fi
fi
if [ -n "${target_hostext_images}" ]; then
	info "Target hostapp extensions:"
	for hostext in ${target_hostext_images}; do
		info " - ${hostext}"
	done
fi

# Detect containers engine
if which docker > /dev/null 2>&1; then
    DOCKER=docker
elif which rce > /dev/null 2>&1; then
    DOCKER=rce
elif which balena > /dev/null 2>&1; then
    DOCKER=balena
else
    fail "No container engine detected."
fi

# Clean up dead containers from previous failed removals.
# Dead containers are left behind when removal is attempted while the overlay
# is mounted in the root filesystem. After reboot, mobynit skips them so they
# are no longer mounted and can be safely removed.
for cid in $(${DOCKER} ps --all --quiet --no-trunc --filter "label=${BALENA_HOSTAPP_EXTENSIONS_LABEL}=${BALENA_HOSTAPP_EXTENSIONS_VALUE}"); do
	if is_container_dead "${cid}"; then
		imagetag=$(${DOCKER} inspect "${cid}" --format='{{.Config.Image}}' 2>/dev/null) || imagetag="${cid}"
		info "Cleaning up dead container: ${imagetag}"
		${DOCKER} rm --force --volumes "${cid}" > /dev/null 2>&1 || true
	fi
done

# Verify targets
for hostext in ${target_hostext_images}; do
	imageid=$(${DOCKER} inspect -f '{{.Id}}' "${hostext}" 2> /dev/null) || imageid=""
	if [ -n "${imageid}" ]; then
		continue
	fi

	# Authenticate to registry before checking remote availability
	registry=$(get_registry "${hostext}")
	if [ -n "${registry}" ]; then
		registry_login "${registry}" || true
	fi

	# Use --insecure flag for registries configured in insecure-registries
	insecure_flag=""
	if is_insecure_registry "${registry}"; then
		insecure_flag="--insecure"
	fi

	# shellcheck disable=SC2086
	if ! DOCKER_CLI_EXPERIMENTAL=enabled ${DOCKER} manifest inspect ${insecure_flag} "${hostext}" > /dev/null 2>&1; then
		error "${hostext} not found in repository - bailing out with no action taken."
		exit 1
	fi
done

info "Removing previous hostapp extensions"

# Remove containers not in the target list. Iterate over containers directly
for cid in $(${DOCKER} ps --all --quiet --no-trunc --filter "label=${BALENA_HOSTAPP_EXTENSIONS_LABEL}=${BALENA_HOSTAPP_EXTENSIONS_VALUE}"); do
	imagetag=$(${DOCKER} inspect "${cid}" --format='{{.Config.Image}}' 2>/dev/null)
	case " ${target_hostext_images} " in
		*" ${imagetag} "*)
			info " - Preserving $imagetag"
			continue
			;;
	esac
	if is_mounted_in_root_overlay "${cid}"; then
		info " - ${imagetag} mounted in root overlay, deferring cleanup to reboot"
		${DOCKER} rm --force --volumes "${cid}" > /dev/null 2>&1 || true
	else
		umount_merged "${cid}"
		${DOCKER} rm --force --volumes "${cid}" > /dev/null 2>&1 || true
	fi
done

# Clean up extension images no longer used by any container
for image in $(${DOCKER} images --all --quiet --filter "label=${BALENA_HOSTAPP_EXTENSIONS_LABEL}=${BALENA_HOSTAPP_EXTENSIONS_VALUE}"); do
	cids=$(${DOCKER} ps --all --quiet --filter ancestor="${image}" | head -1)
	if [ -z "${cids}" ]; then
		${DOCKER} rmi --force "$image" > /dev/null 2>&1 || true
	fi
done

if [ -n "${target_hostext_images}" ]; then
	info "Installing new hostapp extensions:"
	for hostext in ${target_hostext_images}; do
		info " - ${hostext}"
		imageid=$(${DOCKER} inspect -f '{{.Id}}' "${hostext}" 2> /dev/null) || imageid=""

		# Check if container already exists for this image
		if [ -n "${imageid}" ]; then
			container_exists=$(${DOCKER} ps --all --quiet --filter ancestor="${imageid}" | head -1)
			if [ -n "${container_exists}" ] && ! is_container_dead "${container_exists}"; then
				info "   - already installed"
				update_current_host_extensions
				continue
			fi
			info "   - image exists, creating container"
		else
			# Image doesn't exist, need to pull
			if ! ${DOCKER} pull "${hostext}" > /dev/null 2>&1; then
				error "   - failed to pull"
				install_failed=1
				break
			fi
		fi

		# Build label arguments and create container
		label_args="--label ${BALENA_HOSTAPP_EXTENSIONS_LABEL}=${BALENA_HOSTAPP_EXTENSIONS_VALUE}"
		if [ -n "${extra_labels}" ]; then
			for label in $(echo "${extra_labels}" | tr ',' ' '); do
				label_args="${label_args} --label ${label}"
			done
		fi
		# shellcheck disable=SC2086
		if ! ${DOCKER} create --runtime="bare" ${label_args} "${hostext}" none > /dev/null 2>&1; then
			error "   - failed to create container"
			install_failed=1
			break
		fi
		update_current_host_extensions
		info "   - done"
	done
fi

# Update config.json accordingly
tmpdir=$(mktemp -d)
tmpfile="${tmpdir}/config.tmp"
if [ -z "${current_hostext_images}" ]; then
	# No hostext images, remove entry
	jq . > "${tmpfile}" < "${CONFIG_PATH}"
	sed -i "/hostappExtensions/d" "${tmpfile}"
else
	# Store the current hostapp extensions into config.json
	jq -S '. |= .+ {"hostappExtensions"}' > "${tmpfile}" < "${CONFIG_PATH}"
	content=$(jq -S ". |= .+ {\"hostappExtensions\" : \"${current_hostext_images}\"}" < "${tmpfile}")
	echo "${content}" > "${tmpfile}"
fi
"${MV}" "${tmpfile}" "${CONFIG_PATH}"
rm -rf "${tmpdir}"

if [ -n "${current_hostext_images}" ]; then
	info "The following hostapp extensions will be available on the next boot:"
	for hostext in ${current_hostext_images}; do
		info " - ${hostext}"
	done
	if [ "$reboot" = 1 ]; then
		info "Rebooting now."
		reboot
	fi
else
	info "Nothing else to do"
fi

if [ "${install_failed}" -eq 1 ]; then
	exit 1
fi

exit 0
