#!/bin/sh

#
# Script to deploy the boot files from rootfs (in container) to the boot
# partition
#

set -o errexit

# Variables
container_id="$1"
bootfiles_list="@RESIN_BOOTFILES_LIST@"
boot_fingerprint="@RESIN_BOOT_FINGERPRINT@"
bootfiles_blacklist="\
	/config.json \
	/config.txt \
	/splash/resin-logo.png \
	"
boot_mountpoint="/mnt/boot"

# Checks if a file is present in the blacklist
# Arguments:
# 	$1: file to be checked
# Return value:
# 	0: file is blacklisted
# 	1: file is not blacklisted
isBlacklisted() {
	local _file="$1"
	for b in $bootfiles_blacklist; do
		if [ "$b" = "$_file" ]; then
			return 0
		fi
	done
	return 1
}

# Checks if a file was modified by verifying its fingerprint
# Arguments:
# 	$1: file to be checked
# Return value:
# 	0: file is modified
# 	1: file is not modified
isModified() {
	local _file="$1"
	local _current_md5
	_current_md5="$(md5sum "$boot_mountpoint/$_file" | awk '{print $1}')"
	local _initial_md5
	_initial_md5="$(grep "$_file" < "$boot_mountpoint/$boot_fingerprint" | awk '{print $1}')"
	if [ "$_current_md5" != "$_initial_md5" ]; then
		return 0
	else
		return 1
	fi
}

# Copies a file from a container to the boot filesystem atomically and durable
# Arguments:
# 	$1: boot partition file
copyFromContainer() {
	local _file="$1"
	mkdir -p "$boot_mountpoint/$(dirname "$_file")"
	balena cp "$container_id:/resin-boot/$_file" "$boot_mountpoint/$_file.new"
	sync -f $boot_mountpoint
	mv "$boot_mountpoint/$_file.new" "$boot_mountpoint/$_file"
	sync -f $boot_mountpoint
}

# Deploys file from container to boot partition
# Arguments:
# 	$1: file path relative to boot partition's root
deploy() {
	local _file="$1"
	printf "[INFO] Deploying %s%s..." "${boot_mountpoint}" "${_file}"
	if isModified "$_file"; then
		if isBlacklisted "$_file"; then
			printf " file modified but blacklisted. Ignoring.\n"
		else
			printf " overwriting modified file..."
			copyFromContainer "$_file"
			printf " done.\n"
		fi
	else
		copyFromContainer "$_file"
		printf " done.\n"
	fi
}


#
# MAIN
#

export DOCKER_HOST="unix:///var/run/balena-host.sock"

if [ -z "$container_id" ]; then
	echo "[ERROR] Container ID provided as an argument is needed."
	exit 1
fi

bootfiles_list_new="/tmp/$(basename $bootfiles_list).new"
balena cp "$container_id:$bootfiles_list" "$bootfiles_list_new"

# Do a dry run for copying the boot files and figure out if we would get in a
# out of space situation
boot_mnt="$(findmnt --noheadings --canonicalize --output TARGET /dev/disk/by-label/resin-boot)"
boot_space="$(df -k --output=avail /mnt/boot | grep -v Avail)"
available="$boot_space"
available_threshold="512" # All sizes in K
echo -n "[INFO] Checking if boot partition can accommodate the new update... "
while read entry; do
	filename="$(echo $entry | cut -d' ' -f1)"
	if isBlacklisted $filename; then
		continue
	fi
	filesize="$(echo $entry | cut -d' ' -f2)"
	if [ "$filesize" = "$filename" ]; then
		# Old OS didn't include sizes too so we skip this check
		echo -n "skipped... "
		break
	fi
	available="$(expr $available - $filesize)"
	if [ -f "${boot_mnt}${filename}" ]; then
		available="$(expr $available + $(du -sk ${boot_mnt}${filename} | cut -f1))"
	fi
	if [ "$available" -lt "$available_threshold" ]; then
		echo "[ERROR] Boot files copy operations will fail with out of space error."
		exit 1
	fi
done < "$bootfiles_list_new"
echo "success."

# Deploy all files in the bootfiles list
while read entry; do
	filename="$(echo $entry | cut -d' ' -f1)"
	deploy "$filename"
done < "$bootfiles_list_new"
